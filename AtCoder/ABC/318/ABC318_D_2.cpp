// 2025/01/05 11:54:46
// 
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int N;
pair<int,int> edge_pair(int C){
    ;
}
int main(){
    cin >> N;
    vector weights(N, vector(N, -1));
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            cin >> weights[i][j];
            weights[j][i] = weights[i][j];
        }
    }

    /* debug */
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cerr << weights[i][j] << ' ';
        }
        cerr << endl;
    }

    int C_MAX = N * (N - 1) / 2;
    for (int C = 0; C < C_MAX; C++) {
        auto [e0, e1] = edge_pair(C);
    }

    // cout <<  << endl;
    return 0;
}
/*
全探索のオーダーすら分からん。(2025/01/05 12:03:13)
4 -> 3*4/2
辺の数はN * (N - 1) / 2？
辺の全探索なら2^120
頂点なら15^16ってところか。
オーダー的にはDPっぽい感じだよなあ。(2025/01/05 12:07:51)

   0  1  2  3 
0  x  1  5  4
1     x 11 13
2   
3

    1  0
01  1  0
02  5  1
03  5  5
12 12  5
13 13 12
23  7 13

DP 0  1  2  3 
0  0  1  5  4
1     5 11 13
2       13 11
3          13
これで行けるのか？WAなら知らんぞ？(2025/01/05 12:33:21)

DP  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
 0  0  5  6  5  2  1  7  9  7  2  5  5  2  4  7  6
 1     9 17 16 16 18 17  8 18 15 19 17 17 15 19 12
 2       19 
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15

  01   02   03   12   13   23
0  0    0    0    0    0    0
1  1,0  5,0  4,0  7,0  8,0  6,0
2  1,8
3  

解説をチラ見。bitDP…？
頂点を消費しているかどうかの集合ってこと？(2025/01/05 13:05:42)
2^4 = 16
   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  O(2^16)
1  0  0  0  1  0  5  7  0  0  4  8  0  6  0  0  0  O(2^16^2)
2  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  A

違うな。
0000
0011 0101 0110 1001 1010 1100
1111
こういうことか。

16C0
16C2
16C4
16C6
16C8 = 16 15 14 13 12 11 10 9 / 8 7 6 5 4 3 2 1 = 15 13 2 11 3 = 143 90 = 12870
16C10
16C12
16C14
16C16

bitのnext_permutation()どうしたらよい？いちいちbit配列に変えるのはなあ…(2025/01/05 13:28:55)
popcount()==2のint値を列挙…
16C2と合成… XOR取って0になるやつのみ処理か。
*/
