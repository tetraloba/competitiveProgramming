// 2025/03/09 17:03:03
// 2025/03/09 17:57:00 AC.
#include <iostream>
#include <vector>
#define NUMVAR 10
using namespace std;
int main(){
    string S;
    cin >> S;
    int C = 0;
    vector<int> cnt(1 << NUMVAR);
    for (char c : S) {
        C ^= (1 << c - '0');
        // cerr << C << ' ';
        cnt[C]++;
    }
    // cerr << endl;

    /* debug */
    // for (int c : cnt) {
    //     cerr << c << ' ';
    // }
    // cerr << endl;

    long long ans = cnt[0];
    for (char c : S) {
        vector<int> new_cnt(1 << NUMVAR);
        for (int i = 0; i < cnt.size(); i++) {
            new_cnt[i ^ (1 << c - '0')] = cnt[i];
        }
        cnt = new_cnt;
        cnt[0]--;
        ans += cnt[0];
        /* debug */
        // for (int c : cnt) {
        //     cerr << c << ' ';
        // }
        // cerr << endl;
    }
    cout << ans << endl;
    return 0;
}
/*
20230322
202303
20230322
023032
22
BITとかセグ木じゃないよね？(2025/03/09 17:07:02)
10種類の数値について，数が偶数個なら良い。
前後からの累積和とかで解けるやつ？(2025/03/09 17:09:05)
クエリじゃなくて数え上げなんだよなあ…(2025/03/09 17:10:52)
  10120211
0001112222
1011222234
2000011222

0221110000
1433222210
2222211000

数はどうでもよくて，偶数か奇数かだけ。
  10120211
0001110000
1011000010
2000011000

0001110000
1011000010
2000011000
どちらから累積和とっても同じか…(2025/03/09 17:16:54)

10個の数字のindexリストにしてみたら？(2025/03/09 17:17:42)
0: 1 4
1: 0 2 6 7
2: 3 5

状態は2^10個しか無い。状態の数を数えておいて，うまく更新できればO(|S|*2^10)か？(2025/03/09 17:24:11)

   20230322
0 001110000
1 000000000
2 011000010
3 000011000
   25198040
0  01110000
1  00000000
2  00111101
3  00011000
   015DC404
0123456789ABCD
21101100110000
21002100000011
*/
