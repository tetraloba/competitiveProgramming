// 2025/12/14 00:30:42
// 2025/12/14 01:54:06 AC.
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

pair<int, int> DIR4[4] = {{0, 1}, {-1, 0}, {0, -1}, {1, 0}};
bool in_range(vector<vector<char>>& S, int h, int w) {
    return 0 <= h && h < S.size() && 0 <= w && w < S[0].size();
}
bool become_black(vector<vector<char>>& S, int h, int w) {
    if (S[h][w] != '.') {
        return false;
    }
    int black_cnt = 0;
    for (auto [dh, dw] : DIR4) {
        black_cnt += (in_range(S, h + dh, w + dw) && S[h + dh][w + dw] == '#');
    }
    return black_cnt == 1;
}

int main(){
    int H, W;
    cin >> H >> W;
    vector<vector<char>> S(H, vector<char>(W));
    for (int h = 0; h < H; h++) {
        for (int w = 0; w < W; w++) {
            cin >> S[h][w];
        }
    }

    int black_cnt = 0;
    queue<pair<int, int>> que;
    for (int h = 0; h < H; h++) {
        for (int w = 0; w < W; w++) {
            if (S[h][w] == '#') {
                que.push({h, w});
            }
        }
    }
    while (!que.empty()) {
        black_cnt += que.size();
        // cerr << "black_cnt: " << black_cnt << endl; // debug
        queue<pair<int, int>> next_que;
        while (!que.empty()) {
            auto [h, w] = que.front(); que.pop();
            // cerr << '(' << h << ',' << w << ')' << ' '; // debug
            for (auto [dh, dw] : DIR4) {
                if (!in_range(S, h + dh, w + dw)) {
                    continue;
                }
                if (!become_black(S, h + dh, w + dw)) {
                    continue;
                }
                next_que.push({h + dh, w + dw});
            }
        }
        while (!next_que.empty()) {
            auto [h, w] = next_que.front(); next_que.pop();
            S[h][w] = '#';
            que.push({h, w});
        }
        /* debug */
        // cerr << endl;
        // for (int h = 0; h < H; h++) {
        //     for (int w = 0; w < W; w++) {
        //         cerr << S[h][w];
        //     }
        //     cerr << endl;
        // }
    }


    cout << black_cnt << endl;
    return 0;
}
/*
2025/12/14 00:32:01
まあ、最大HW(=3*10^5)回で静止するよね。
2025/12/14 00:33:10
setか何かで管理すればできそうな気もするけど。
2025/12/14 00:34:46
全ての黒マスからBFS状に。
「ちょうど1つ」なので黒マスは1回しか消費されない。
(ある黒マスが隣接するマスを黒く染める可能性があるのは、自身が黒くなった次のフェーズのみ)

2025/12/14 01:25:02
分からん。なぜかex.2が65になる。

..........
....0.....
0.......0.
......0...
.......0..
.....0....
..........
..........
..0...0...
.......0..

....1.....
1..101..1.
01..1.1101
1....10.1.
.....1.01.
....1011..
.....1....
..1...1...
.101.10...
..1....01.

2...1...2.
1.2101..1.
012.1.1101
1....10.1.
2....1.012
...21011..
..2..1.2..
..1...12..
2101.10.2.
..1..2.012

233.1.2323
1.2101..1.
012.1.1101
1.3..10.1.
23.3.1.012
3..21011.3
.32..1.23.
3.1...12..
2101.10.2.
3.1.32.012

2025/12/14 01:46:21
フェーズ内の塗りが同時に行われないなら57になるけど…
え、違うよね？

....1.....
1..101..1.
01..1.1.01
1....10.1.
.......0..
....101...
.....1....
..1...1...
.101.10...
..1....01.

2...1...2.
1.2101.21.
01..1.1.01
1....10.1.
2......0..
...2101...
..2..1....
..1...12..
2101.10.2.
..1..2.012

23..1...23
1.2101.21.
01..1.1.01
1....10.1.
23.3...0..
3..2101...
.32..1.3..
3.1...12..
2101.10.2.
3.1.32.012

23..1...23
1.2101.21.
01..1.1.01
1..4.10.1.
23.3...0..
3..2101...
.32..1.34.
3.1...12..
2101.10.2.
3.1.32.012

23..1...23 5
1.2101.21. 3
01..1.1.01 4
1..4.10.1. 5
23.3...0.. 6
3..2101.5. 4
.32..1.345 4
3.1...12.. 6
2101.10.2. 3
3.1.32.012 3

2025/12/14 02:11:59
become_black()で対象マスが白であることを確認していなかったから(9,7)を2回塗っていたわ…
*/

