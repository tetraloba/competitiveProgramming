// 2024/04/24 22:24:08
// 2024/04/24 23:47:25 4WA
// 2024/04/24 23:52:07 1WA
// 2024/04/24 23:58:24 AC.
#include <iostream>
#include <vector>
#include <map>
using namespace std;
using ll=long long;
int main(){
    ll N;
    cin >> N;
    vector<ll> A(N);
    for (ll &a : A) {
        cin >> a;
    }
    map<ll, ll> cnt;
    for (ll a : A) {
        cnt[a]++;
    }
    ll remain = N; // 3つ目の候補数
    ll dup_num = 0; // 重複数
    map<ll, ll> appear; // 登場回数
    ll ans = 0;
    for (ll i = 0; i < N; i++) {
        remain--;
        cnt[A[i]]--;
        // cout << (remain - cnt[A[i]]) * (i - appear[A[i]]) - dup_num + (cnt[A[i]] + 1) * appear[A[i]] << ' '; // debug
        ans += (remain - cnt[A[i]]) * (i - appear[A[i]]);
        ans -= dup_num; // 重複分を引く
        ans += (cnt[A[i]] + 1) * appear[A[i]]; // 引きすぎた分 (ベン図でいう積集合)
        dup_num += cnt[A[i]];
        dup_num -= appear[A[i]];
        appear[A[i]]++;
    }
    // cout << endl; // debug
    cout << ans << endl;
    return 0;
}
/*
とりあえず順番も値の大小関係も意味を持たないので、
各数字の数という情報にまで落とし込んで良い。(2024/04/24 22:26:25)
そのうえで、例えば数が
2,3,5個である場合
2個のものを選んだ場合、2つめは8(10-2)通り

ってやっていくとO(N^2)かかるな。

いや順番関係有るのか。(2024/04/24 22:28:55)
2, 3, 2, 4, 5 の場合
2, 3, 4を選ぶのと3, 2, 4を選ぶのは区別されるのか。

より右にその数字が何個出てくるかは求められるのか？(2024/04/24 22:37:03)
O(N)でいけるか。C++のmapならO(N log N)
でもコピーしたらO(N^2)か。マトリックス的に考えても。
全体でカウントしておいて左から見て引いていけばよいか。(2024/04/24 22:40:44)
先読みするのと都度計算するので時間計算量変わってくるんだな。
差分だけ保持すると考えれば良いのか。(2024/04/24 22:41:58)
ほんで、より右に何個有るかを足していけばよいと。
普通にやるとO(N^2)なので、動的計画法的なのに落とし込むのかしら。(2024/04/24 22:45:52)
     1  1  0  0  2  2 0 0 1 0 0 0 1 0 0
rem 14 13 12 11 10  9 8 7 6 5 4 3 2 1 0
     3  1  4  1  5  9 2 6 5 3 5 8 9 7 9
3 1  - 11 11 10  7  6 7 6 4 0 4 3 1 1 0
1 1  -  - 11  0  7  7 8 7 5 
4 0  -  -  - 11  8  7 
1 0  -  -  -  -  8  7
5 2  -  -  -  -  -  5
9
2
6
5
3
5
8
9
7
9

行が１つ目の数字i, 列が2つ目の数字jとして
remainN - remain[i] - remain[j]って感じだよな。(2024/04/24 23:07:42)
でremain[j]の総和を求めておけばO(N)に落とせそう。
*/
