// 2024/04/14 17:05:26
// 2024/04/14 18:26:04 WA
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main(){
    int N, D;
    cin >> N >> D;
    vector<pair<int, int>> walls; // (座標, (lなら-1 rなら1))
    for (int i = 0; i < N; i++) {
        int l, r;
        cin >> l >> r;
        walls.push_back({l - D + 1, -1});
        walls.push_back({r, 1});
    }

    sort(walls.begin(), walls.end());
    bool pre_l = false; // 直前がl(-1)だったか
    int ans = 0;
    for (auto w : walls) {
        // cout << '(' << w.first << ',' << w.second << ')'; // debug
        if (pre_l && w.second == 1) {
            ans++;
        }
        pre_l = w.second == -1;
    }
    cout << ans << endl;
    return 0;
}
/*
範囲が重複する場合は纏めてしまうという感じか。(2024/04/14 17:07:44)
まあ昇順配列にすれば二分探索できるか。(2024/04/14 17:10:07)
後の壁のほうが大きいと壁の数が減る可能性が出てくるのか。先に壁のサイズで降順ソートしておく？(2024/04/14 17:21:02)
いや、間の壁が後から出てくると挿入に時間がかかる(O(N))のか。(2024/04/14 17:31:27)
重複数自体はimos法で求められるか。(2024/04/14 17:32:45)

1( 2) 4( 7) 5( 9) 入力O(N)
1( 2) 4( 5( 7) 9) ソートO(N log N)
これで解けるか(´・ω・｀) (2024/04/14 17:34:43)

(-1,-1)(2,-1)(2,1)(3,-1)(7,1)(9,1)
-1( 2( 2) 3( 7) 9)
ここからどうやって回数を求めるのかがわからない (2024/04/14 18:06:40)
1 2 1 2 1 0
(()())
--
 ---
   --

-1( 2) 2( 2( 7) 9)
-1( 2( 2( 2) 7) 9)
((()))
1 2 3 2 1 0

2024/04/14 18:19:52
入力例3
(0,-1)(0,-1)(100,-1)(100,1)(1000,1)(9981,-1)(44353,1)(999999999,-1)(1000000000,1)(1000000000,1)
((())()())
1 2 3 2 1 2 1 2 1 0
上がった後下がる回数？ うーん。。。 (2024/04/14 18:21:24)
直接閉じている括弧の数と言っても良いのかな。(2024/04/14 18:22:24)

()(())
(()(()()))
1回殴って
   (()()) -> あと2回
   (( ())) -> あと1回
この違いか。(2024/04/14 18:30:18)
じゃあ単純に括弧まで落とし込むのでは駄目だな。
壁の重複数が減るところで殴るという発想は間違っていないと思う。
殴った後消えた壁を追跡する必要がありそう。(2024/04/14 18:32:19)
*/
