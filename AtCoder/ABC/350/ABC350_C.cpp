// 2024/05/25 12:52:21
// 2024/05/25 13:21:29 11WA
// 2024/05/25 13:40:47 AC.
#include <iostream>
#include <vector>
using namespace std;
int main(){
    int N;
    cin >> N;
    vector<int> A(N), idx(N);

    for (int i = 0; i < N; i++) {
        cin >> A[i];
        A[i]--;
        idx[A[i]] = i;
    }

    int K = 0;
    vector<pair<int ,int>> av; // ans_vector
    for (int i = 0; i < N; i++) {
        if (i == idx[i]) {
            continue;
        }
        av.push_back({i, idx[i]});
        swap(A[i], A[idx[i]]);
        swap(idx[A[i]], idx[A[idx[i]]]);
        K++;
    }

    cout << K << endl;
    for (auto a : av) {
        cout << a.first + 1 << ' ' << a.second + 1 << endl;
    }
    return 0;
}
/*
あーこれなんとか数ってやつよね。
バブルソート書いてスワップ回数数えても良いけど、計算できたはず…
考えるか。(2024/05/25 12:53:58)
3 2 4 5 1 (0)
1 3 2 4 5 (4)
1 2 3 4 5 (5)
+4 0 -2 -1 -1

1 5 4 2 3 (0)
1 2 5 4 3 (2)
1 2 3 5 4 (4)
1 2 3 4 5 (5)
0 +2 +2 -1 -3
1 3 1 -2 -1
あ、回数求める問題じゃなかったわ。バブルソート実装するだけね。(2024/05/25 13:02:16)
いや、一見O(N^3)だが、間に合うんだっけ？(2024/05/25 13:06:19)
スワップ回数最大何回だ…？
log(N)とかならO(N^2 log(N))で間に合いそう…？

ちがうわそもそもバブルソートじゃないしO(N^2)だめだ。(2024/05/25 13:10:25)
やっぱりしばらく競プロやらないと感覚狂うなあ・・・

間違えた、A[i]とA[j]じゃなくてiとjを出力するのか。(2024/05/25 13:23:01)
2 3 0 1 4
2 3 0 1 4

2 0 1
1 2 0

*/
