// 2024/03/15 18:12:19
// 2024/03/15 21:03:36 19WA
// 2024/03/15 21:17:51 AC.
#include <iostream>
#include <vector>
#include <string>
#define MAX 101
using namespace std;
int main(){
    string T;
    int N;
    cin >> T >> N;
    vector<vector<string>> S(N);
    for (vector<string> &s : S) {
        int A;
        cin >> A;
        s = vector<string>(A);
        for (int i = 0; i < A; i++) {
            cin >> s[i];
        }
    }
    vector<vector<vector<int>>> P(N, vector<vector<int>>(T.size() + 1, vector<int>(0)));
    for (int i = 0; i < N; i++) {
        for (string s_e : S[i]) {
            int p = 0;
            while (true) {
                p = T.find(s_e, p);
                if (p == string::npos) break;
                P[i][p].push_back(p + s_e.size());
                p++;
            }
        }
    }
    // /* debug */
    // for (int i = 0; i < N; i++) {
    //     cout << i << ':';
    //     for (int j = 0; j < T.size(); j++) {
    //         cout << j << '(';
    //         for (int k : P[i][j]) {
    //             cout << k << ' ';
    //         }
    //         cout << "), ";
    //     }
    //     cout << endl;
    // }

    vector<vector<int>> cost(N, vector<int>(T.size() + 1, MAX));
    cost[0][0] = 0;
    for (int i : P[0][0]) {
        cost[0][i] = 1;
    }
    for (int bag = 1; bag < N; bag++) {
        cost[bag][0] = 0;
        for (int pos = 0; pos < T.size() + 1; pos++) {
            cost[bag][pos] = min(cost[bag - 1][pos], cost[bag][pos]);
            for (int i : P[bag][pos]) {
                cost[bag][i] = min(cost[bag - 1][pos] + 1, cost[bag][i]);
            }
        }
    }
    // /* debug */
    // for (vector<int> c : cost) {
    //     for (int i : c) {
    //         cout << i << ' ';
    //     }
    //     cout << endl;
    // }

    int ans = cost[N - 1][T.size()];
    ans = ans == MAX ? -1 : ans;
    cout << ans << endl;
    return 0;
}
/*
なにこれ…
順番とか関係有るん？(2024/03/15 18:15:14)
あ、一周しかできないのか…(2024/03/15 18:17:52)
組み合わせ全探索して10^100 * 10 って感じか。
T(100文字)の区切り方も無数にあるしなあ…
人間がやるなら、一致しているもので長いものから試して手戻りを繰り返すんだろうけれど…(2024/03/15 18:22:22)
これ袋の中の文字列は短い順に並んでいるっていう保証はないよね？(2024/03/15 18:24:17)
メモ化再帰とかで上手くやれそうな気もするんだけどねえ。(2024/03/15 18:24:53)
動的計画法とか…？うーん、、、(2024/03/15 18:25:21)
> 袋の中の文字列は短い順に並んでいるっていう保証
無いな。入力例3に反例あり。(2024/03/15 18:29:03)
いや、序盤が長いからトータルで最善とは限らないのか。(2024/03/15 18:33:47)
んぁ～、各文字列の、T内に入れられる場所の探索は10*10*100で行けるのか。(2024/03/15 18:38:00)
入力例3の
aaabbbbcccc
6
2 aa aaa
2 dd ddd
2 ab aabb
4 bbaa bbbc bbb bbcc
2 cc bcc
3 ccc cccc ccccc
を
2 0-1 0-2
2 - -
2 2-3 1-4
4 - 4-7 3-5 4-6 5-8
2 7-8 8-9 9-10 6-8
3 7-9 7-10 -
に落とし込める。
これで探索していけば比較的速そう？
でも全探索だと結局10^100近くになるのか？アーリーリターンの計算量計算できない。(2024/03/15 18:43:19)
あーでも動的計画法やな。(2024/03/15 18:49:07)
↑の例はケツから探索するとスムーズだけどたまたまだよなあ…
とりあえず再帰で全探索組んでみる？意外と10^10くらいで通ったりして？(2024/03/15 18:53:01)
とりあえず開始位置終了位置の情報に置き換えるところまでは実装しよう。(2024/03/15 18:55:05)
できた(2024/03/15 19:34:21)
```
0:0(1 2 ), 1(2 ), 2(), 3(), 4(), 5(), 6(), 7(), 8(), 9(), 10(), 
1:0(), 1(), 2(), 3(), 4(), 5(), 6(), 7(), 8(), 9(), 10(), 
2:0(), 1(4 ), 2(3 ), 3(), 4(), 5(), 6(), 7(), 8(), 9(), 10(), 
3:0(), 1(), 2(), 3(5 ), 4(7 6 ), 5(8 ), 6(), 7(), 8(), 9(), 10(), 
4:0(), 1(), 2(), 3(), 4(), 5(), 6(8 ), 7(8 ), 8(9 ), 9(10 ), 10(), 
5:0(), 1(), 2(), 3(), 4(), 5(), 6(), 7(9 10 ), 8(10 ), 9(), 10(), 
```
選ばない場合があるから、すべての0()には0が必要か。つまり初期値0(0) (2024/03/15 19:35:24)
いや選ばないのは例外処理じゃないと無理か。1()でも敢えて選択しない可能性あるし。 (2024/03/15 19:37:38)
ケツから行ったほうが良いか、ケツから行っても意味的に同じか？
でも3で4()だったときに3以降で4がないことが分かったら同じこと繰り返すのは無駄だからメモ化は必要そうだよな。
メモ化再帰な感じするけどなあ(2024/03/15 19:42:03)
aab...
0:a aa
1:a
2:b
みたいな時に
0:a, 1:aの時と0:aaの時は処理が被るよねって話ね。(2024/03/15 19:44:23)
一度やって駄目だった数字はvectorから消せばよいのか。setの方が良いか？重そうだけどなあ()

aaa
0: a aa aaa
1: a aa aaa
2: a aa aaa
みたいなのがいちばん大変なのかな。(2024/03/15 20:00:44)

メモは100*100*100かな。一つのmap<int>にできるかしら。(2024/03/15 20:04:00)

動的計画法だとbagの順番が上手く扱えなくて、以下のパターンで困りそう。(2024/03/15 20:18:21)
abc
0: a
1: b
2: ab c
bまで行くのに一番安いのは2だけどそれだとcが取れなくなる。
bag毎にやれば良いのか…
1まで""で行くのはコスト0
1まで"a"で行くのはコスト1
2まで""で行くのはコスト0
2まで"a"で行くのはコスト1
2まで"ab"で行くのはコスト2
3まで""で行くのはコスト0
3まで"a"で行くのはコスト1
3まで"ab"で行くのはコストmin(""からのコスト0+1, "ab"からのコスト2+0)
3まで"abc"で行くのはコスト3(=2+1)
これなら100*100とかで行けそう？(2024/03/15 20:28:35)

19WA (2024/03/15 21:03:36)
aaaaa
2
1 aaaaa
1 bbbbb
が-1になるな。(2024/03/15 21:14:37)
*/
