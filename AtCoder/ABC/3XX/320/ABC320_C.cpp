// 2024/03/11 18:35:12
// 2024/03/11 19:26:47 AC.
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main(){
    int M;
    cin >> M;
    string S[3];
    for (string &s : S) {
        cin >> s;
    }
    vector<int> p[3][10];
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < M; j++) {
            p[i][S[i][j] - '0'].push_back(j);
            p[i][S[i][j] - '0'].push_back(j + M);
            p[i][S[i][j] - '0'].push_back(j + M + M);
        }
    }
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 10; j++) {
            sort(p[i][j].begin(), p[i][j].end());
            /* debug */
            // cout << i << '-' << j << ':';
            // for (int k : p[i][j]) {
            //     cout << k << ' ';
            // }
            // cout << endl;
        }
    }
    int ans = M * 3 + 1;
    for (int i = 0; i < 10; i++) {
        if (!p[0][i].size() || !p[1][i].size() || !p[2][i].size()) {
            continue; // いずれかのリールに数字がない場合
        }
        int order[6][3] = {{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0}};
        for (int j = 0; j < 6; j++) {
            int t0, t1 = -1, t2 = -1;
            t0 = p[order[j][0]][i][0];
            for (int k = 0; k < 3; k++) { // 一つでも数字が有れば必ず3つはある。(n, n+M, n+M+M)
                if (t0 < p[order[j][1]][i][k]) {
                    t1 = p[order[j][1]][i][k];
                    break;
                }
            }
            if (t1 == -1) {
                continue;
            }
            for (int k = 0; k < 3; k++) {
                if (t1 < p[order[j][2]][i][k]) {
                    t2 = p[order[j][2]][i][k];
                    break;
                }
            }
            if (t2 == -1) {
                continue;
            }
            // cout << i << ':' << t2 << endl; // debug
            ans = t2 < ans ? t2 : ans;
        }
    }
    cout << (ans == M * 3 + 1 ? -1 : ans) << endl;
    return 0;
}
/*
最速で止められるのは1番目からか。0番目はケツと思って良いな。 ← 違うわ。文字は1番目から数えるのね。
各リールについて各数字の有る番目を小さい方から並べて、
各リールから重複無しで小さい方優先で3つ取り出す。
1937458062
8124690357
2385760149

9374580621
1246903578
3857601492

0-1:0 10 20 
0-2:9 19 29 
0-3:2 12 22 
0-4:4 14 24 
0-5:5 15 25 
0-6:8 18 28 
0-7:3 13 23 
0-8:6 16 26 
0-9:1 11 21 
1-0:6 16 26 
1-1:1 11 21 
1-2:2 12 22 
1-3:7 17 27 
1-4:3 13 23 
1-5:8 18 28 
1-6:4 14 24 
1-7:9 19 29 
1-8:0 10 20 
1-9:5 15 25 
2-0:6 16 26 
2-1:7 17 27 
2-2:0 10 20 
2-3:1 11 21 
2-4:8 18 28 
2-5:3 13 23 
2-6:5 15 25 
2-7:4 14 24 
2-8:2 12 22 
2-9:9 19 29 
Mを0~2回まで足したやつも入れておくべきか。
0:6 7 16
1:0 1 7
2:0 2 9
3:1 2 7
4:3 4 8
5:3 5 8
6:4 5 8
7:3 4 9
8:0 2 6
9:1 5 9
各数字について、各リールでの最速3つまでを出して並べて、
1 2 3
1 2 4
1 2 3
みたいな場合どう処理すれば良い？(2024/03/11 19:10:09)
(1,a)(1,b)(1,c)(2,a)(2,b)(2,c)(3,a)(3,c)(4,b) 無駄か。
まあ3!通り全探索したほうが早いか…(2024/03/11 19:12:24)

*/
