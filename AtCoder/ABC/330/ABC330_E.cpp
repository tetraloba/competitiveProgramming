// 2024/04/11 21:33:53
// 2024/04/11 23:19:03 10WA
// 2024/04/11 23:26:36 3WA
// 2024/04/11 23:34:02 AC.
#include <iostream>
#include <vector>
#include <map>
#include <set>
using namespace std;
int main(){
    int N, Q;
    cin >> N >> Q;
    vector<int> A(N);
    for (int &a : A) {
        cin >> a;
    }

    map<int, int> cnt;
    for (int a : A) {
        cnt[a]++;
    }

    set<int> mexs;
    for (int i = 0; i <= 200000; i++) {
        mexs.insert(i);
    }
    for (auto [k, v] : cnt) {
        mexs.erase(k);
    }

    for (int q = 0; q < Q; q++) {
        int i, x;
        cin >> i >> x;
        i--;
        cnt[A[i]]--;
        if (cnt[A[i]] == 0) {
            mexs.insert(A[i]);
        }
        A[i] = x;
        cnt[A[i]]++;
        mexs.erase(A[i]);
        cout << *mexs.begin() << endl;
    }
    return 0;
}
/*
mapで各値の数を管理する。
Aに登場しない数の昇順リストを作る？
削除や追加操作が行われるので連結リストで実装する。
連結リストだと検索に時間がかかるので検索用にmapを使う？(2024/04/11 21:46:34)
いや10^9のリストは無理だ。(2024/04/11 21:48:42)
mexがAに追加された時に次のmexを効率的に探せれば良い。
全探索すると遅い。連続部分を飛ばせれば良い。そういうデータ構造作ればよいのでは？(2024/04/11 21:52:10)
1,2,3,4,5,8,9,11,13
を(1,5),(8,9),(11,11),(13,13)という連結リストで表現すればよいわけでしょう。(2024/04/11 21:54:03)
それだと連結リストの検索が難しい。
2分木でそれっぽいものが作れそうな気はする(2024/04/11 22:32:29)
set(A)を昇順に並べたものを葉に持ってきて、2分木で、親はその数の連続するグループの一番うしろの数みたいな。
待って、Aiは10^9まであるけど、Nが200000までである以上、mexが200000を超えることはないから2000000より大は無視してよくね？(2024/04/11 22:52:03)
C++だしsetで良いか。
*/
