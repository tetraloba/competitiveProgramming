//2022/08/26 08:10:27
//
#include <iostream>
#include <vector>
using namespace std;
int main(){
    int H, W, K, x1, y1, x2, y2;
    cin >> H >> W >> K >> x1 >> y1 >> x2 >> y2;
    ;
    cout <<  << endl;
    return 0;
}
//どこでも2手で行ける(2通り)から、余分な手で寄り道できるパターン全部ってことか。
//((W-1)+(H-1))^余分な手数ってところか？
// いや、最短1手の場合も考慮しないとか。余分な手数が変わる。sample3
// --o
// ---
// --x
// というか、先に自由に動き回って最後に1手または2手でゴールすると考える？これ場合分けむずくね。
// o-
// -x
// こういうのは3手では行けないしな。(3マス以上あれば問題なさげ)
// o-
// --
// --
// これは2手以上でどこへでも行けるはず?
// いや
// ox
// --
// --
// --
// ここだけは2手じゃ無理。
// そうか、余分な手で、ゴールまで2手で行ける場所に行くことを考えればよいのか。2022/08/26 08:28:35
// o-
// -x
// は
// xに2手で行ける場所がoのみであり、最初の(余分な)1手でoに行けないから3手が0通りなんだ。
// 2列または2行がある場合、その数分2手で行けない場所が(必ず?)1つ生じる。
// もっと一般化するならば、2手でゴールと同じ行または列からゴールに向かう方法は、そうでない場所から行く方法より少ない。
// 同行または同列なら(H - 2) + (W - 2)ただし同行かつ同列(つまりx)ならば0。
// それ以外の一般解は(H - 1) + (W - 1)
// Sample3は余分な1手目で行ける場所が4通りあり、内2通りは一般解で
// 違うな。一般解は各点から2通り、同行はW-2, 同列はH-2, 同行同列は0